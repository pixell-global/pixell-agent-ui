import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import path from 'path';
import { URL } from 'url';

export interface HealthResponse {
  ok: boolean;
  message: string;
  timestamp: number;
}

export interface ActionResult {
  success: boolean;
  result: string;
  error?: string;
  request_id: string;
  duration_ms: number;
  metadata?: Record<string, string>;
}

export interface GrpcConnectionConfig {
  host: string;
  port: number;
  useTLS: boolean;
}

/**
 * Parse PAF Core Agent URL to extract gRPC connection details
 * Examples:
 *   http://localhost:8000 â†’ { host: 'localhost', port: 8000, useTLS: false }
 *   http://host.com â†’ { host: 'host.com', port: 80, useTLS: false }
 *   https://host.com â†’ { host: 'host.com', port: 443, useTLS: true }
 */
export function parseUrlForGrpc(url: string): GrpcConnectionConfig {
  const parsed = new URL(url);

  const host = parsed.hostname;
  const useTLS = parsed.protocol === 'https:';

  // Extract port or use default based on protocol
  let port: number;
  if (parsed.port) {
    port = parseInt(parsed.port, 10);
  } else {
    port = useTLS ? 443 : 80;
  }

  return { host, port, useTLS };
}

/**
 * gRPC client for PAF Core Agent A2A communication
 * Implements the AgentService proto definition
 */
export class PafCoreGrpcClient {
  private client: any;
  private serviceDefinition: any;

  constructor(pafCoreUrl: string) {
    // Parse URL to get connection config
    const config = parseUrlForGrpc(pafCoreUrl);
    const target = `${config.host}:${config.port}`;

    console.log(`ðŸ”— Initializing gRPC client: ${target} (TLS: ${config.useTLS})`);

    // Load proto definition
    const PROTO_PATH = path.join(__dirname, '../../proto/agent.proto');
    const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
      keepCase: true,
      longs: String,
      enums: String,
      defaults: true,
      oneofs: true
    });

    const protoDescriptor = grpc.loadPackageDefinition(packageDefinition) as any;
    this.serviceDefinition = protoDescriptor.pixell.agent.AgentService;

    // Create credentials
    const credentials = config.useTLS
      ? grpc.credentials.createSsl()
      : grpc.credentials.createInsecure();

    // Create client
    this.client = new this.serviceDefinition(target, credentials);
  }

  /**
   * Health check - calls Health RPC
   */
  async health(): Promise<HealthResponse> {
    return new Promise((resolve, reject) => {
      this.client.Health({}, (error: grpc.ServiceError | null, response: any) => {
        if (error) {
          reject(error);
        } else {
          resolve({
            ok: response.ok,
            message: response.message,
            timestamp: parseInt(response.timestamp, 10)
          });
        }
      });
    });
  }

  /**
   * Invoke action - calls Invoke RPC
   */
  async invoke(
    action: string,
    parameters: Record<string, any>
  ): Promise<ActionResult> {
    return new Promise((resolve, reject) => {
      // Convert parameters to string map (protobuf requirement)
      const stringParams: Record<string, string> = {};
      for (const [key, value] of Object.entries(parameters)) {
        stringParams[key] = typeof value === 'string' ? value : JSON.stringify(value);
      }

      const request = {
        action,
        parameters: stringParams,
        request_id: '' // Will be generated by agent if empty
      };

      this.client.Invoke(request, (error: grpc.ServiceError | null, response: any) => {
        if (error) {
          reject(error);
        } else {
          resolve({
            success: response.success,
            result: response.result,
            error: response.error || undefined,
            request_id: response.request_id,
            duration_ms: parseInt(response.duration_ms, 10),
            metadata: response.metadata ? Object.fromEntries(
              Object.entries(response.metadata)
            ) : undefined
          });
        }
      });
    });
  }

  /**
   * Get capabilities - calls DescribeCapabilities RPC
   */
  async getCapabilities(): Promise<{ methods: string[]; metadata: Record<string, string> }> {
    return new Promise((resolve, reject) => {
      this.client.DescribeCapabilities({}, (error: grpc.ServiceError | null, response: any) => {
        if (error) {
          reject(error);
        } else {
          resolve({
            methods: response.methods || [],
            metadata: response.metadata ? Object.fromEntries(
              Object.entries(response.metadata)
            ) : {}
          });
        }
      });
    });
  }

  /**
   * Close the gRPC connection
   */
  close(): void {
    if (this.client) {
      grpc.closeClient(this.client);
    }
  }
}
