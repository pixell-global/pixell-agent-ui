name: Deploy to ECS (OIDC)

on:
  push:
    branches:
      - main

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: pixell-web
  ECS_CLUSTER: pixell-web-cluster
  ECS_SERVICE: pixell-web-simple
  TASK_FAMILY: pixell-web-simple
  CONTAINER_NAME: web

jobs:
  deploy:
    name: Deploy to ECS Fargate
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::636212886452:role/GithubActionsEcsDeployRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Get AWS Account ID
        id: aws-account
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "account_id=$AWS_ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "AWS Account ID: $AWS_ACCOUNT_ID"

      - name: Check ECR repository
        run: |
          if ! aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} >/dev/null 2>&1; then
            echo "Creating ECR repository: ${{ env.ECR_REPOSITORY }}"
            aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }}
          else
            echo "ECR repository already exists"
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Generate image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${TIMESTAMP}-${SHORT_SHA}"
          echo "tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Image tag: $IMAGE_TAG"

      - name: Build Docker image
        env:
          # Firebase environment variables (build-time, will be bundled into client)
          NEXT_PUBLIC_FIREBASE_API_KEY: ${{ secrets.NEXT_PUBLIC_FIREBASE_API_KEY }}
          NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN: ${{ secrets.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN }}
          NEXT_PUBLIC_FIREBASE_PROJECT_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_PROJECT_ID }}
          NEXT_PUBLIC_FIREBASE_APP_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_APP_ID }}
          NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID }}
          NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET: ${{ secrets.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET }}
          # PAF Core Agent URL (server-side only)
          PAF_CORE_AGENT_URL: ${{ secrets.PAF_CORE_AGENT_URL }}
          # Other public environment variables
          NEXT_PUBLIC_SITE_URL: ${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_BASE_URL: ${{ secrets.NEXT_PUBLIC_BASE_URL }}
          NEXT_PUBLIC_PAF_CORE_AGENT_URL: ${{ secrets.NEXT_PUBLIC_PAF_CORE_AGENT_URL }}
          NEXT_PUBLIC_ORCHESTRATOR_URL: ${{ secrets.NEXT_PUBLIC_ORCHESTRATOR_URL }}
        run: |
          docker build \
            --platform linux/amd64 \
            --build-arg APP_ENV=prod \
            --build-arg PAF_CORE_AGENT_URL="${PAF_CORE_AGENT_URL:-}" \
            --build-arg NEXT_PUBLIC_FIREBASE_API_KEY="${NEXT_PUBLIC_FIREBASE_API_KEY:-}" \
            --build-arg NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN="${NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN:-}" \
            --build-arg NEXT_PUBLIC_FIREBASE_PROJECT_ID="${NEXT_PUBLIC_FIREBASE_PROJECT_ID:-}" \
            --build-arg NEXT_PUBLIC_FIREBASE_APP_ID="${NEXT_PUBLIC_FIREBASE_APP_ID:-}" \
            --build-arg NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID="${NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID:-}" \
            --build-arg NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET="${NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET:-}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${NEXT_PUBLIC_SITE_URL:-}" \
            --build-arg NEXT_PUBLIC_BASE_URL="${NEXT_PUBLIC_BASE_URL:-}" \
            --build-arg NEXT_PUBLIC_PAF_CORE_AGENT_URL="${NEXT_PUBLIC_PAF_CORE_AGENT_URL:-}" \
            --build-arg NEXT_PUBLIC_ORCHESTRATOR_URL="${NEXT_PUBLIC_ORCHESTRATOR_URL:-}" \
            -t ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }} \
            -t ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest \
            .

      - name: Push Docker image to ECR
        run: |
          docker push ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}
          docker push ${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:latest

      - name: Update task definition with new image
        id: task-def
        run: |
          IMAGE_URI="${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}"
          
          aws secretsmanager get-secret-value \
            --secret-id pixell/taskdef/pixell-web-simple \
            --region ${{ env.AWS_REGION }} \
            --query SecretString \
            --output text > taskdef.json

          jq \
            --arg image "$IMAGE_URI" \
            --arg name "${{ env.CONTAINER_NAME }}" \
            '.containerDefinitions |= map(if .name == $name then .image = $image else . end)' \
            taskdef.json > taskdef-updated.json

          echo "Updated task definition with image: $IMAGE_URI"

      - name: Register new task definition
        id: register-task
        run: |
          # Register the new task definition
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://taskdef-updated.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          if [ -z "$TASK_DEF_ARN" ] || [[ "$TASK_DEF_ARN" == *"Error"* ]]; then
            echo "Failed to register task definition"
            exit 1
          fi
          
          echo "task-def-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "Registered task definition: $TASK_DEF_ARN"
          
          # Clean up temporary file
          rm -f taskdef-updated.json

      - name: Update ECS service
        run: |
          echo "Updating ECS service with new task definition..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.register-task.outputs.task-def-arn }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for deployment to stabilize
        run: |
          echo "Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}
          echo "Deployment stabilized"

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          
          # Check service status
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].status' \
            --output text)
          
          echo "Service status: $SERVICE_STATUS"
          
          if [ "$SERVICE_STATUS" != "ACTIVE" ]; then
            echo "Error: Service is not ACTIVE"
            exit 1
          fi
          
          # Get running task count
          RUNNING_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].runningCount' \
            --output text)
          
          DESIRED_COUNT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].desiredCount' \
            --output text)
          
          echo "Running tasks: $RUNNING_COUNT/$DESIRED_COUNT"
          
          if [ "$RUNNING_COUNT" -lt "$DESIRED_COUNT" ]; then
            echo "Warning: Not all tasks are running"
          fi
          
          echo "Deployment verification completed"

      - name: Deployment summary
        if: always()
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ steps.aws-account.outputs.account_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Task Definition**: \`${{ steps.register-task.outputs.task-def-arn }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: \`${{ env.ECS_CLUSTER }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: \`${{ env.ECS_SERVICE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Monitoring Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# View logs" >> $GITHUB_STEP_SUMMARY
          echo "aws logs tail /ecs/${{ env.ECS_SERVICE }} --follow --region ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Service status" >> $GITHUB_STEP_SUMMARY
          echo "aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --region ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

